# GO语言知识点

## `for ... range`

```go
// 相当于js中的   forEach
arr := []int{1, 2, 3}
for index, value := arr {

}
```

## `_`符号

```go
// 代表空值，接收但是后面用不着
arr := []int{1, 2, 3}
for _, value := arr {

}
```

## 传递变长参数

```go
// 跟js中的扩展运算符类似
// 定义函数的时候形参可用   args ...type  传递
// 调用函数的时候实参可用   args...  传递

func test (a int, b int, args ...int) {
	// do sth
}
arr := [3, 3, 3]
test(1, 2, arr...)
```

## `switch`相关

```go
// switch 判断条件可以为空，为空的时候，case对应值为true时执行相关代码
switch {
  case condition1:
  	// sss
  case condition2:
  	// sss
  default:
  	// sss
}
// switch不需要break操作，默认执行一个case之后就会跳出判断循环，想要穿透可以加fallthrough,穿透方式为直接穿透下一层，不管接下来的条件是不是符合
switch a {
  case 1:
  	// ss
  case 2:
  	// ss
  	fallthrough
  case 3:
  	// 如果满足case 2,此条会直接执行
  default:
  	// ss
}
```

## 标签

```go
LABELSS:
	// code
	continue LABELSS
// 跳出循环到LABELSS对应的下面一行代码执行


// 也可配合 goto label 使用
// 跳转到对应的 label 处执行代码
```



## 指针

```go
// 可以通过 & 取到变量的指针
str := "string"
strPointer := &str

// 可以通过 * 取到指针的数据
// *strPointer 就是 str

// 在函数中传递指针为参数，此时可以通过指针来改变指向的数据来改变原有值
func main() {
  n := 0
  reply := &n
  test(reply)
}

func test(reply *int) {
  *reply = 2 // 把 main 函数中的 n 值改变为 2
}
```

## `defer`推迟执行代码

```go
// 推迟执行代码，在函数内部，执行完 return 语句之后或者退出函数之前执行
  func test1() {
    fmt.Println("1")
    defer test2()
    fmt.Println("3")
  }

  func test2() {
    fmr.Println("2")
  } // 输出顺序  1 3 2


// 一个函数内部包含多个 defer 的时候，按照顺序逆序输出
  for i := 0; i < 5; i++ {
    defer fmt.Println(i)
  } // 输出顺序   4 3 2 1 0


// 可以 defer 后面的操作可以接收参数，实参为在代码中所处位置参数的值，不是执行完整个函数时实参的值
  i := 0
  defer fmt.Println(i)
  i++
  return
  // 传递的参数为0，打印结果为0s
  // 传递给 defer 后面函数的参数如果为函数的结果的话，会先执行函数返回结果，然后再执行下面的语句
  func main() {
    fmt.Println(1)
    defer fmt.Println(test2())
    fmt.Println(2)
  }

  func test2() int {
    fmt.Println("test2")
    return 3
  } // 输出结果顺序为  1 test2 2 3
```

## 回调函数

```go
// 声明回调函数接收参数的类型
func test(a int, b int, cb func(int, int)) {
	cb(a, b)
}

// 回调函数有返回值得时候声明函数返回值类型
func test(a int, b int, cb func(int, int) int) int {
	ret := cb(a, b)
	fmt.Println(ret)
	return ret
}
```

## IIFE自执行函数

```go
// 只能在函数内部使用，不能再最外层写
func main() {
  func (a int, b int) {
    fmt.Println(a, b)
  }(3, 4)
}

// 也可以像 js 中那样加上括号
func main() {
  (func (a int, b int) {
    fmt.Println(a, b)
  })(3, 4)
}
```

## 函数返回值

```go
func test() (ret int) {
  return 2  // 此时 ret 的值被赋值为2，如果在函数内部使用 defer 的时候可以取得此时的 2 值，并且可以更改此值来更改返回值
}
```

## 数组

```go
// 定义数组方式
// var identifier [len]type
var arr1 [5]int // 类型为 [5]int 型，传递给函数的时候是传递值，将值复制给参数
// var identifier = new([len]int)
var arr2 = new([5]int) // 类型为 *[5]int 型，传递给函数为指针，可通过其更改原数组
  // arr2 不可以直接赋值给 arr1 ，可以转换为值然后赋值
  arr1 = *arr2
  // arr1 不可以直接赋值给 arr2 ，可以转换为指针然后赋值
  arr2 = &arr1
var arr = [...]int{1, 2, 3, 4, 5} // 根据元素推断长度
var arr = [5]int{1: 2, 4: 5} // [0, 2, 0, 0, 5]  根据下标定义数组

// 二维数组定义
arr := [3][2]int{
		[2]int{1, 2},
		[2]int{2, 3},
		[2]int{3, 4},
	}



// 数组赋值的时候发生内存拷贝
var arr [5]int
arr1 = arr
arr[2] = 2 // 此时 arr[2] 为 2，arr1[2] 为0
```

## 切片

> 切片是一个长度可变的数组

数组的传递是值传递，切片的传递是引用，传递给函数的时候，切片作为参数的时候，是可以通过函数改变原有切片的

```go
// 切片的创建方法
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[start:end] //  包括 start 不包括 end，如果 start 和 end 相同的时候就是一个空切片

slice := []int{1, 2, 3, 4, 5}

slice := make([]type, len, cap) // cap 长度可选, len 为切片长度，cap 为切片最大长度



// 切片长度可扩展，最大可扩展到的长度为切片起始点到在相关数组内部位置到数组末尾的长度

arr := [5]int{1, 2, 3, 4, 5}
slice := arr[2:3]   	// [3]
slice1 := slice[0:2]	// [3 4]
```

### 切片相关方法

`make:` make([]type, len, cap) --> slice

​	len 为slice长度， cap切片最大长度

`copy:` copy(sliceTo, sliceFrom) --> int

​	复制切片，sliceTo为复制到的切片内，sliceFrom为被复制的切片，返回值sliceTo被覆盖个数，如果sliceFrom长度小于等于sliceTo长度，此时返回sliceFrom的长度，否则返回sliceTo的长度

`append:` append(slice, ...args) --> slice

​	为slice切片增加元素，返回一个新的slice切片，如果append的元素在参数切片之后，cap超过底层数组，则重新分配一个底层数组给返回的slice。如果没超过cap，新的slice跟参数slice指向同一个底层数组。

`len:` len(slice) --> int

​	返回切片当前长度

`cap:` cap(slice) --> int

​	返回切片最大长度

